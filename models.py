from copy import deepcopy
from globals import MY_COUNTRY
from random import randint

# In this file all Objects used throughout the project are represented


# Country is used to represent an individual user-defined country in the simulation
class Country:
    name: str
    resource_dict: dict

    def __init__(self, name: str, resource_dict: dict):
        self.name = name
        self.resources = resource_dict


# ResourceWeight is used to represent an individual user-defined resource weight in the simulation
class ResourceWeight:
    name: str
    resource_weight: dict
    display_name: str

    def __init__(self, name: str, resource_weight: dict, display_name: str):
        self.name = name
        self.resource_weight = resource_weight
        self.display_name = display_name


# Schedule is used to compare and track partial and full schedules while being generated by the searching algorithm
class Schedule:
    utility: float
    country_list: list
    partial_schedule: list

    def __init__(self, utility: float, country_list: list, partial_schedule: list):
        self.utility = utility
        self.country_list = country_list
        self.partial_schedule = partial_schedule

    def __lt__(self, other) -> bool:
        if self.utility == other.utility:
            return len(self.partial_schedule) > len(other.partial_schedule)
        else:
            return self.utility < other.utility

    def __eq__(self, other) -> bool:
        if self.utility == other.utility:
            return len(self.partial_schedule) == len(other.partial_schedule)
        else:
            return self.utility == other.utility


# Transfer is used to represent user defined transfers from transfer_templates.py in the simulation
class Transfer:
    current_world_state: list
    export_country: Country
    import_country: Country
    transfer_templates: tuple

    def __init__(self, current_world_state: list, export_country: Country, import_country: Country, transfer_tuple: tuple):
        self.current_world_state = deepcopy(current_world_state)
        self.export_country = export_country
        self.import_country = import_country
        self.transfer_tuple = transfer_tuple

    def execute(self) -> list:
        resource, quantity = self.transfer_tuple[0], self.transfer_tuple[1]
        self.export_country = next((country for country in self.current_world_state if country.name == self.export_country), None)
        self.import_country = next((country for country in self.current_world_state if country.name == self.import_country), None)
        self.export_country.resources[resource] -= quantity
        self.import_country.resources[resource] += quantity
        return self.current_world_state

    def to_string(self, resource_names: list) -> str:
        resource_code, resource_quantity = self.transfer_tuple[0], self.transfer_tuple[1]
        resource_name = next((resource for resource in resource_names if resource.name == resource_code), None).display_name
        string = "(TRANSFER (" + str(round(resource_quantity, 2)) + " " + resource_name + ") From " + self.export_country.name + " To " + self.import_country.name + ")"
        return string


# Transform is used to represent user defined transforms in the simulation
class Transform:
    transform_name: str
    input_resources: dict
    output_resources: dict
    transform_multiplier: int

    def __init__(self, transform_name: str, input_resources: dict, output_resources: dict):
        self.transform_name = transform_name
        self.input_resources = input_resources
        self.output_resources = output_resources
        self.transform_multiplier = 1

    def execute(self, current_world_state: list) -> list:
        current_world_state = deepcopy(current_world_state)
        my_country = next((country for country in current_world_state if country.name == MY_COUNTRY), None)
        self.calculate_multiplier(my_country)
        for resource in self.input_resources:
            my_country.resources[resource] = my_country.resources[resource] - self.input_resources[resource] * self.transform_multiplier
        for resource in self.output_resources:
            my_country.resources[resource] = my_country.resources[resource] + self.output_resources[resource] * self.transform_multiplier
        return current_world_state

    def execute_given_multiplier(self, current_world_state: list, multiplier: int) -> list:
        current_world_state = deepcopy(current_world_state)
        my_country = next((country for country in current_world_state if country.name == MY_COUNTRY), None)
        for resource in self.input_resources:
            my_country.resources[resource] = my_country.resources[resource] - self.input_resources[resource] * multiplier
        for resource in self.output_resources:
            my_country.resources[resource] = my_country.resources[resource] + self.output_resources[resource] * multiplier
        return current_world_state

    def calculate_multiplier(self, current_country: Country) -> None:
        multiplier = -1
        current_resources = current_country.resources
        for resource_type in self.input_resources:
            available = current_resources[resource_type]
            if available > 0:
                if multiplier == -1:
                    multiplier = int(available / self.input_resources[resource_type])
                else:
                    multiplier = min(multiplier, int(available / self.input_resources[resource_type]))
            else:
                multiplier = 0
        self.transform_multiplier = multiplier

    def to_string(self, resource_names: list) -> str:
        output_string = "(TRANSFORM (" + str(self.transform_multiplier) + "x " + self.transform_name + ") " + MY_COUNTRY + "\n\t\t(INPUTS: "
        for resource_code in self.input_resources:
            resource_name = next((resource for resource in resource_names if resource.name == resource_code), None).display_name
            output_string += "\n\t\t\t(" + resource_name + ": " + str(self.input_resources[resource_code] * self.transform_multiplier) + ")"
        output_string += ") \n\t\t(OUTPUTS: "
        for resource_code in self.output_resources:
            resource_name = next((resource for resource in resource_names if resource.name == resource_code), None).display_name
            output_string += "\n\t\t\t(" + resource_name + ": " + str(self.output_resources[resource_code] * self.transform_multiplier) + ")"
        output_string += "))"
        return output_string

# RandomEvent is used to represent random events that can occur in schedules
class RandomEvent:
    random_event_name: str
    event_multiplier: float
    probability_of_success: float
    was_successful: bool
    resources_effected_list: list

    def __init__(self, random_event_name: str, event_multiplier: float, probability_of_success: float, resources_effected_list: list):
        self.random_event_name = random_event_name
        self.event_multiplier = event_multiplier
        self.probability_of_success = probability_of_success
        self.resources_effected_list = resources_effected_list
        self.was_successful = False

    def execute(self, current_world_state: list) -> list:
        random_number = randint(0, 10)
        if random_number * .1 <= self.probability_of_success:
            self.was_successful = True
        current_world_state = deepcopy(current_world_state)
        if self.was_successful:
            my_country = next((country for country in current_world_state if country.name == MY_COUNTRY), None)
            for resource in self.resources_effected_list:
                remaining_quantity = my_country.resources[resource] * self.event_multiplier
                if remaining_quantity > 0:
                    my_country.resources[resource] = remaining_quantity
                else:
                    my_country.resources[resource] = 0

        self.was_successful = False
        return current_world_state

    def to_string(self, resource_names: list) -> str:
        output_string = "(RANDOM EVENT: " + self.random_event_name + ")"
        return output_string